---
title: ISAs and Machine Representation
discussion: 796055702966763560
---

![XKCD comic "real programmers"](https://imgs.xkcd.com/comics/real_programmers.png)

We will begin with what should be a review of ISAs and machine representation of instructions.
These topics were covered mostly in ECS 50.
However, we will be using the [RISC-V open source ISA](https://riscv.org/).
If you did not take ECS 50 or find yourself struggling to keep up in this first set of lectures, please refer to Chapter 2 in *Computer Organization and Design*.

{% include reading.html section="Chapter 2 (Skim only)" %}

{% include reading-grad.html section="Appendix A (Skim only)" %}

{% include video.html %}

## What is an ISA?

{% include reading.html section="Section 1.3" %}

{% include reading-grad.html section="Section 1.3" %}

First, let's start by discussing *what is the **architecture**?*
In the video below, I describe the different parts of the computing stack and how the architecture defines how the software and hardware interacts.

If you're interested in the details of the three ISAs I mentioned in the above video you can follow the links for the ISA manuals for [RISC-V](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf) ([github link](https://github.com/riscv/riscv-isa-manual)), [Intel X86](https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html), and [ARM](https://developer.arm.com/documentation/ddi0487/latest).


### RISC vs CISC

<iframe width="608" height="402" src="https://www.youtube.com/embed/3LVeEjsn8Ts?start=788&end=1000" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Callback to the [Turing Lecture](https://www.youtube.com/watch?v=3LVeEjsn8Ts).
From 13:08-16:40 talks about *why* we moved from CISC ISAs to RISC ISAs.
You can (optionally) read a [blog post](https://www.sigarch.org/riscy-history/) that Dave Patterson wrote which gives some more background on this fundamental change in computer architecture.

## RISC-V

{% include reading.html section="Sections 2.6-2.11 (Optional/skim)" %}

{% include reading.html section="Appendix A.9" %}

![RISC-V logo](https://content.riscv.org/wp-content/uploads/2018/09/riscv-logo.png)

In this class, we will be using the 32-bit RISC-V ISA.
Specifically, we'll be using the rv32i variant of RISC-V.
You can find *all* of the details about the RISC-V ISA in the [RISC-V Specification document](https://riscv.org/specifications/isa-spec-pdf/).

You can find the instructions that we care about, the 32-bit integer instructions, in the [opcode table]({{"/img/riscv-instr.pdf" | relative_url}}).

More details are available in Chapter 2 of *Computer Organization and Design* and the *RISC-V Reader*.

## Machine code examples

{% include reading.html section="Section 2.5" %}

Finally, let's put this all together and look at how an instruction is executed on a simple processor (this is an intro to [the next section]({{'modules/processor architecture/single-cycle' | relative_url}})).
These two videos go through two different full examples of decoding and executing RISC-V instructions.
The first video show a simple R-type instruction (`add`) and the second video a load instruction (`lw`).
Note that the first video's `add` example is basically the answer to the question in [assignment 1]({{'modules/dino cpu/assignment1' | relative_url}}).

### `add` example

{% include video.html id="0_oc8059yb" %}

### `lw` example

{% include video.html id="0_cf2ocpfl" %}

### Optional further reading: Compiling, linking, and assembling

{% include reading.html section="Sections 2.13 and 2.15" %}
